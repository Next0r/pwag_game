<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: engine.boxCollider.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: engine.boxCollider.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { Matrix4 } = require("./engine.math.matrix4");
const { Vector3 } = require("./engine.math.vector3");
const { Mesh } = require("./engine.utilities.mesh");
const { Vector4 } = require("./engine.math.vector4");

/**
 * Allows to create mesh based colliders. Takes part in OBB collision detection.
 */
class BoxCollider {
  /**
   * Creates new box collider with specified identifier
   * @param {string} colliderID unique string that represents box collider instance
   */
  constructor(colliderID) {
    /**
     * Unique id of this box collider
     * @type {string}
     */
    this.id = colliderID;
    /**
     * Size of this box collider, should be generated by recalculate method first
     * @type {Vector3}
     */
    this.size = new Vector3();
    /**
     * Center of this box collider, should be generated by recalculate method first
     * @type {Vector3}
     */
    this.center = new Vector3();
    /**
     * Radius of this box collider, represents box collider as sphere, used to improve 
     * collision detection performance
     * @type {number}
     */
    this.radius = 0;
    /**
     * Transformation matrix of this box collider, to make collider follow some kind
     * of game object, put reference to it's transformation matrix here
     * @type {Matrix4}
     */
    this.transformationMatrix = new Matrix4();
    /**
     * Function that is fired when this collider hits other box collider
     * @type {function}
     * @param {string} colliderID id of other collider that has hit this one
     */
    this.onCollision = (colliderID) => {};
  }

  /**
   * Changes box collider size, center and radius to match given mesh
   * @param {Mesh} mesh instance of mesh that represents base for box collider size calculation
   * @returns {BoxCollider} reference to self for easier method chaining
   */
  recalculate(mesh) {
    let posMin = new Vector3();
    let posMax = new Vector3();
    posMax.x = posMin.x = mesh.positions[0].x;
    posMax.y = posMin.y = mesh.positions[0].y;
    posMax.z = posMin.z = mesh.positions[0].z;

    for (let position of mesh.positions) {
      if (position.x > posMax.x) {
        posMax.x = position.x;
      } else if (position.x &lt; posMin.x) {
        posMin.x = position.x;
      }

      if (position.y > posMax.y) {
        posMax.y = position.y;
      } else if (position.y &lt; posMin.y) {
        posMin.y = position.y;
      }

      if (position.z > posMax.z) {
        posMax.z = position.z;
      } else if (position.z &lt; posMin.z) {
        posMin.z = position.z;
      }
    }

    this.center.x = (posMin.x + posMax.x) * 0.5;
    this.center.y = (posMin.y + posMax.y) * 0.5;
    this.center.z = (posMin.z + posMax.z) * 0.5;

    this.size.x = posMax.x - posMin.x;
    this.size.y = posMax.y - posMin.y;
    this.size.z = posMax.z - posMin.z;

    this.radius = posMax.subtract(this.center).length();
    return this;
  }

  /**
   * Allows to acquire vertices of box collider boundary
   * @returns {Vector4[]} array of box collider vertices modified with transformation matrix
   */
  getVertices() {
    const xs = this.size.x * 0.5;
    const ys = this.size.y * 0.5;
    const zs = this.size.z * 0.5;
    const vertices = [
      this.transformationMatrix.vectorMultiply(
        new Vector4(
          this.center.x - xs,
          this.center.y - ys,
          this.center.z - zs,
          1
        )
      ),
      this.transformationMatrix.vectorMultiply(
        new Vector4(
          this.center.x - xs,
          this.center.y - ys,
          this.center.z + zs,
          1
        )
      ),
      this.transformationMatrix.vectorMultiply(
        new Vector4(
          this.center.x - xs,
          this.center.y + ys,
          this.center.z - zs,
          1
        )
      ),
      this.transformationMatrix.vectorMultiply(
        new Vector4(
          this.center.x - xs,
          this.center.y + ys,
          this.center.z + zs,
          1
        )
      ),
      this.transformationMatrix.vectorMultiply(
        new Vector4(
          this.center.x + xs,
          this.center.y - ys,
          this.center.z - zs,
          1
        )
      ),
      this.transformationMatrix.vectorMultiply(
        new Vector4(
          this.center.x + xs,
          this.center.y - ys,
          this.center.z + zs,
          1
        )
      ),
      this.transformationMatrix.vectorMultiply(
        new Vector4(
          this.center.x + xs,
          this.center.y + ys,
          this.center.z - zs,
          1
        )
      ),
      this.transformationMatrix.vectorMultiply(
        new Vector4(
          this.center.x + xs,
          this.center.y + ys,
          this.center.z + zs,
          1
        )
      ),
    ];
    return vertices;
  }

  /**
   * Allows to acquire box collider "normals" that represent forward, right and up vectors of oriented box
   * @returns {Vector4[]} array of forward, right and up vectors of oriented box
   */
  getNormals() {
    const xs = this.size.x * 0.5;
    const ys = this.size.y * 0.5;
    const zs = this.size.z * 0.5;
    const normals = [];

    let v0 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x + xs, this.center.y - ys, this.center.z + zs, 1)
    );
    let v1 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x + xs, this.center.y - ys, this.center.z - zs, 1)
    );
    let v2 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x + xs, this.center.y + ys, this.center.z + zs, 1)
    );

    let e0 = v1.subtract(v0);
    let e1 = v2.subtract(v0);

    normals.push(e0.cross(e1).normalize());

    v0 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x - xs, this.center.y + ys, this.center.z + zs, 1)
    );
    v1 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x + xs, this.center.y + ys, this.center.z + zs, 1)
    );
    v2 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x - xs, this.center.y + ys, this.center.z - zs, 1)
    );

    e0 = v1.subtract(v0);
    e1 = v2.subtract(v0);

    normals.push(e0.cross(e1).normalize());

    v0 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x - xs, this.center.y - ys, this.center.z + zs, 1)
    );
    v1 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x + xs, this.center.y - ys, this.center.z + zs, 1)
    );
    v2 = this.transformationMatrix.vectorMultiply(
      new Vector4(this.center.x - xs, this.center.y + ys, this.center.z + zs, 1)
    );

    e0 = v1.subtract(v0);
    e1 = v2.subtract(v0);

    normals.push(e0.cross(e1).normalize());
    return normals;
  }

  /**
   * Performs separate axis test (and simple sphere collision test for efficiency)
   * @param {BoxCollide} boxCollider other box collider that might collide with this one
   * @returns {undefined|string} id of colliding box if collision occurred or undefined if not
   */
  doesCollide(boxCollider) {
    const myGlobalPos = this.transformationMatrix
      .getPosition()
      .add(this.center);
    const globalPos = boxCollider.transformationMatrix
      .getPosition()
      .add(boxCollider.center);

    if (
      globalPos.subtract(myGlobalPos).length() >
      this.radius + boxCollider.radius
    ) {
      return;
    }

    const myVertices = this.getVertices();
    const myNormals = this.getNormals();

    const vertices = boxCollider.getVertices();
    const normals = boxCollider.getNormals();

    for (let normal of myNormals) {
      const myMinMax = this._getMinMax(myVertices, normal);
      const minMax = this._getMinMax(vertices, normal);
      if (myMinMax.posMax &lt; minMax.posMin || minMax.posMax &lt; myMinMax.posMin) {
        return undefined;
      }
    }

    for (let normal of normals) {
      const myMinMax = this._getMinMax(myVertices, normal);
      const minMax = this._getMinMax(vertices, normal);
      if (myMinMax.posMax &lt; minMax.posMin || minMax.posMax &lt; myMinMax.posMin) {
        return undefined;
      }
    }

    return boxCollider.id;
  }

  /**
   * @typedef {Object} MinMax
   * @property {number} min value of minimum
   * @property {number} max value of maximum
   */

  /**
   * This method is used to perform separate axis test, usage is not recommended
   * @param {Vector4[]} vertices vertices of collider bounding box
   * @param {Vector4[]} normal forward, right and up vectors of bounding box
   * @returns {MinMax} compartment with minimum and maximum value
   */
  _getMinMax(vertices, normal) {
    const positions = [];

    for (let vertex of vertices) {
      positions.push(vertex.dot(normal));
    }

    let posMin = positions[0];
    let posMax = positions[0];

    for (let position of positions) {
      if (position &lt; posMin) {
        posMin = position;
      }
      if (position > posMax) {
        posMax = position;
      }
    }

    return { posMin, posMax };
  }
}

module.exports.BoxCollider = BoxCollider;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AmbientLight.html">AmbientLight</a></li><li><a href="Attribute.html">Attribute</a></li><li><a href="BoxCollider.html">BoxCollider</a></li><li><a href="Camera.html">Camera</a></li><li><a href="CharacterDescriptor.html">CharacterDescriptor</a></li><li><a href="CollisionSystem.html">CollisionSystem</a></li><li><a href="DirectLight.html">DirectLight</a></li><li><a href="EngineProgram.html">EngineProgram</a></li><li><a href="EngineResources.html">EngineResources</a></li><li><a href="EngineToolbox.html">EngineToolbox</a></li><li><a href="Game.html">Game</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="Input.html">Input</a></li><li><a href="Keyboard.html">Keyboard</a></li><li><a href="Material.html">Material</a></li><li><a href="MaterialAttributes.html">MaterialAttributes</a></li><li><a href="MaterialTextures.html">MaterialTextures</a></li><li><a href="MaterialUniforms.html">MaterialUniforms</a></li><li><a href="Matrix4.html">Matrix4</a></li><li><a href="Mesh.html">Mesh</a></li><li><a href="Mouse.html">Mouse</a></li><li><a href="Projection.html">Projection</a></li><li><a href="Renderer.html">Renderer</a></li><li><a href="ResourceEntry.html">ResourceEntry</a></li><li><a href="Texture.html">Texture</a></li><li><a href="Time.html">Time</a></li><li><a href="Transform.html">Transform</a></li><li><a href="Uniform.html">Uniform</a></li><li><a href="Vector2.html">Vector2</a></li><li><a href="Vector3.html">Vector3</a></li><li><a href="Vector4.html">Vector4</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_createShader">_createShader</a></li><li><a href="global.html#_mat3Det">_mat3Det</a></li><li><a href="global.html#charTable">charTable</a></li><li><a href="global.html#createShaderProgram">createShaderProgram</a></li><li><a href="global.html#createWindow">createWindow</a></li><li><a href="global.html#findInputOffset">findInputOffset</a></li><li><a href="global.html#findSourceElement">findSourceElement</a></li><li><a href="global.html#parseSourceElement">parseSourceElement</a></li><li><a href="global.html#parseTrianglesElement">parseTrianglesElement</a></li><li><a href="global.html#readColladaFile">readColladaFile</a></li><li><a href="global.html#readGeometry">readGeometry</a></li><li><a href="global.html#uniform1fv">uniform1fv</a></li><li><a href="global.html#uniform1iv">uniform1iv</a></li><li><a href="global.html#uniform3fv">uniform3fv</a></li><li><a href="global.html#uniformMatrix4fv">uniformMatrix4fv</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Nov 25 2020 15:46:39 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
