<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: engine.utilities.collada.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: engine.utilities.collada.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { Mesh } = require("./engine.utilities.mesh");
const { EngineToolbox } = require("./engine.toolbox");
const { Vector4 } = require("./engine.math.vector4");
const { Vector3 } = require("./engine.math.vector3");

/**
 * Allows to find source element by name in XML collada file
 * @param {HTMLCollection} sourceElements source elements in XML collada file
 * @param {string} name name of source element that should be found
 * @returns {HTMLElement|undefined} source element representing array of values stored in XML collada file or undefined if element cannot be found
 */
const findSourceElement = (sourceElements, name) => {
  for (let element of sourceElements) {
    const elementID = element.id;
    const IDWords = elementID.split("-");
    if (IDWords.find((item) => item == name)) {
      return element;
    }
  }
  return;
};

/**
 * Acquires useful data from source element e.g. array of vertex positions, normals etc.
 * @param {HTMLElement} sourceElement source element representing array of values stored in XML collada file
 * @returns {Vector3[]|Vector4[]} set of vectors where each represents elements like position, normal vector, uv coordinates etc.
 */
const parseSourceElement = (sourceElement, type = "position") => {
  const floatArrayText = sourceElement.getElementsByTagName("float_array")[0]
    .textContent;
  const floatArrayTextElements = floatArrayText.trim().split(/\s+/);
  const sourceType = type.toUpperCase();
  const dataSet = [];

  switch (sourceType) {
    case "POSITION":
      for (let i = 0; i &lt; floatArrayTextElements.length; i += 3) {
        dataSet.push(
          new Vector4(
            parseFloat(floatArrayTextElements[i]),
            parseFloat(floatArrayTextElements[i + 1]),
            parseFloat(floatArrayTextElements[i + 2]),
            1
          )
        );
      }
      break;
    case "NORMAL":
      for (let i = 0; i &lt; floatArrayTextElements.length; i += 3) {
        dataSet.push(
          new Vector4(
            parseFloat(floatArrayTextElements[i]),
            parseFloat(floatArrayTextElements[i + 1]),
            parseFloat(floatArrayTextElements[i + 2]),
            0
          )
        );
      }
      break;
    case "MAP":
      for (let i = 0; i &lt; floatArrayTextElements.length; i += 2) {
        dataSet.push(
          new Vector3(
            parseFloat(floatArrayTextElements[i]),
            parseFloat(floatArrayTextElements[i + 1]),
            0
          )
        );
      }
      break;
    case "COLOR":
      for (let i = 0; i &lt; floatArrayTextElements.length; i += 4) {
        dataSet.push(
          new Vector4(
            parseFloat(floatArrayTextElements[i]),
            parseFloat(floatArrayTextElements[i + 1]),
            parseFloat(floatArrayTextElements[i + 2]),
            parseFloat(floatArrayTextElements[i + 3])
          )
        );
      }
      break;
  }

  return dataSet;
};

/**
 * Allows to acquire number that represents index in vertex info array
 * for source give, single record in vertex info array might look like [1, 6, 3],
 * offset 1 of source "position" means that sixth position is part of this vertex info
 * @param {HTMLCollection} inputElements collection of input elements stored in XML collada file
 * @param {string} inputSemantic name of input that source offset should be found e.g. POSITION
 * @returns {number|undefined} source offset or undefined if such source is not found
 */
const findInputOffset = (inputElements, inputSemantic) => {
  for (let element of inputElements) {
    const semantic = element.getAttribute("semantic");
    if (semantic.toUpperCase() === inputSemantic.toUpperCase()) {
      return parseInt(element.getAttribute("offset"));
    }
  }
  return;
};

/**
 * @typedef {Object} TrianglesParseResult
 * @property {number} indexOffset offset in vertex info array for vertex (position) source
 * @property {number} normalOffset offset in vertex info array for normal source
 * @property {number} mapOffset offset in vertex info array for map source
 * @property {number} colorOffset offset in vertex info array for color source
 * @property {number[][]} vertices vertex info array
 */

/**
 * Acquires vertex info array from given triangles element and offset for each source of vertex data
 * @param {HTMLElement} trianglesElement XML element of collada file that represents mesh triangles (vertex info array)
 * @returns {TrianglesParseResult} set of source offsets and vertex info array
 */
const parseTrianglesElement = (trianglesElement) => {
  const pElementText = trianglesElement.getElementsByTagName("p")[0]
    .textContent;

  const pElementTextElements = pElementText.trim().split(/\s+/);

  const inputElements = trianglesElement.getElementsByTagName("input");

  const vertices = [];
  let tmpArr = [];
  for (let i = 0; i &lt; pElementTextElements.length; i += inputElements.length) {
    for (let j = i; j &lt; i + inputElements.length; j++) {
      tmpArr.push(parseInt(pElementTextElements[j]));
    }
    vertices.push(tmpArr);
    tmpArr = [];
  }

  const indexOffset = findInputOffset(inputElements, "VERTEX");
  const normalOffset = findInputOffset(inputElements, "NORMAL");
  const mapOffset = findInputOffset(inputElements, "TEXCOORD");
  const colorOffset = findInputOffset(inputElements, "COLOR");

  return { indexOffset, normalOffset, mapOffset, colorOffset, vertices };
};

/**
 * Reads given XML geometry tag from collada file that contains single mesh object definition
 * @param {HTMLElement} geometry XML geometry tag
 * @returns {Mesh} mesh object containing useful vertex data
 */
const readGeometry = (geometry) => {
  const geometryName = geometry.getAttribute("name");
  const meshElement = geometry.getElementsByTagName("mesh")[0];
  const sourceElements = meshElement.getElementsByTagName("source");

  const positionsElement = findSourceElement(sourceElements, "positions");
  const normalsElement = findSourceElement(sourceElements, "normals");
  const mapElement = findSourceElement(sourceElements, "map");
  const colorsElement = findSourceElement(sourceElements, "colors");
  const trianglesElement = meshElement.getElementsByTagName("triangles")[0];

  if (!positionsElement || !normalsElement || !trianglesElement) {
    return;
  }

  const mesh = new Mesh(geometryName);
  mesh.positions = parseSourceElement(positionsElement, "POSITION");
  mesh.normals = parseSourceElement(normalsElement, "NORMAL");
  mesh.map =
    mapElement === undefined ? [] : parseSourceElement(mapElement, "MAP");
  mesh.colors =
    colorsElement === undefined
      ? []
      : parseSourceElement(colorsElement, "COLOR");

  const meshTriangleInfo = parseTrianglesElement(trianglesElement);
  mesh.vertices = meshTriangleInfo.vertices;
  mesh.positionOffset = meshTriangleInfo.indexOffset;
  mesh.normalOffset = meshTriangleInfo.normalOffset;
  mesh.mapOffset = meshTriangleInfo.mapOffset;
  mesh.colorOffset = meshTriangleInfo.colorOffset;

  return mesh;
};

/**
 * Parses collada file into array of mesh objects that can be used as components of game objects
 * @param {string} path path to collada file
 * @returns {Mesh[]} array of meshes stored in collada file
 */
const readColladaFile = (path) => {
  const file = EngineToolbox.readTextFile(path);
  if (!file) {
    return;
  }

  const parser = new DOMParser();
  const xml = parser.parseFromString(file, "text/xml");

  const geometries = xml.getElementsByTagName("geometry");

  const meshes = [];

  for (let geometry of geometries) {
    const mesh = readGeometry(geometry);
    mesh.flipUV();
    meshes.push(mesh);
  }

  return meshes;
};

exports.readColladaFile = readColladaFile;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AmbientLight.html">AmbientLight</a></li><li><a href="Attribute.html">Attribute</a></li><li><a href="BoxCollider.html">BoxCollider</a></li><li><a href="Camera.html">Camera</a></li><li><a href="CharacterDescriptor.html">CharacterDescriptor</a></li><li><a href="CollisionSystem.html">CollisionSystem</a></li><li><a href="DirectLight.html">DirectLight</a></li><li><a href="EngineProgram.html">EngineProgram</a></li><li><a href="EngineResources.html">EngineResources</a></li><li><a href="EngineToolbox.html">EngineToolbox</a></li><li><a href="Game.html">Game</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="Input.html">Input</a></li><li><a href="Keyboard.html">Keyboard</a></li><li><a href="Material.html">Material</a></li><li><a href="MaterialAttributes.html">MaterialAttributes</a></li><li><a href="MaterialTextures.html">MaterialTextures</a></li><li><a href="MaterialUniforms.html">MaterialUniforms</a></li><li><a href="Matrix4.html">Matrix4</a></li><li><a href="Mesh.html">Mesh</a></li><li><a href="Mouse.html">Mouse</a></li><li><a href="Projection.html">Projection</a></li><li><a href="Renderer.html">Renderer</a></li><li><a href="ResourceEntry.html">ResourceEntry</a></li><li><a href="Texture.html">Texture</a></li><li><a href="Time.html">Time</a></li><li><a href="Transform.html">Transform</a></li><li><a href="Uniform.html">Uniform</a></li><li><a href="Vector2.html">Vector2</a></li><li><a href="Vector3.html">Vector3</a></li><li><a href="Vector4.html">Vector4</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_createShader">_createShader</a></li><li><a href="global.html#_mat3Det">_mat3Det</a></li><li><a href="global.html#charTable">charTable</a></li><li><a href="global.html#createShaderProgram">createShaderProgram</a></li><li><a href="global.html#createWindow">createWindow</a></li><li><a href="global.html#findInputOffset">findInputOffset</a></li><li><a href="global.html#findSourceElement">findSourceElement</a></li><li><a href="global.html#parseSourceElement">parseSourceElement</a></li><li><a href="global.html#parseTrianglesElement">parseTrianglesElement</a></li><li><a href="global.html#readColladaFile">readColladaFile</a></li><li><a href="global.html#readGeometry">readGeometry</a></li><li><a href="global.html#uniform1fv">uniform1fv</a></li><li><a href="global.html#uniform1iv">uniform1iv</a></li><li><a href="global.html#uniform3fv">uniform3fv</a></li><li><a href="global.html#uniformMatrix4fv">uniformMatrix4fv</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Nov 25 2020 15:46:39 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
